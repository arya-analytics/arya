---
layout: "@/layouts/Reference.astro"
title: "Building a Custom Driver"
description: "Learn how to create your own integrations with external hardware/systems."
prev: "Troubleshooting"
prevURL: "/reference/python-client/troubleshooting"
---
import { Divider, Note } from "@synnaxlabs/pluto"
import { Image } from "@/components/Media";
import Code from "@/components/code/Code.astro";
export const components = {pre: Code};

The Python client API provides a flexible interface for building custom drivers so that
you can integrate your existing hardware and software systems with Synnax.

<Divider.Divider direction="x" />

## Integration Structure

A typical Synnax integration consists of:

1. Connecting to a cluster through one of our client libraries.
2. Creating the necessary channels to store data and write commands.
3. For writing data to Synnax continuously, setting up a loop to read data from the
   external system and write it to Synnax.
4. For sending commands to external systems, setting up a thread to read commands
   from Synnax and send them to the external system.

## Connecting to Synnax

For all integrations, you'll start by creating a `Client` instance, which will handle
all interactions with the Synnax cluster. For full details on how to set up a client
connection to the cluster, check out the [get started
guide](/reference/python-client/get-started).

A quick way to get started is to install the `synnax` package using pip:

```bash
pip install synnax
```

And passing in the credentials directly:

```python
import synnax as sy

client = sy.Synnax(
    host="demo.synnaxlabs.com",
    port=9090,
    username="synnax",
    password="seldon",
    secure=True
)
```

## Creating Channels

The next step is to create channels that will store related telemetry from/to the external
system. Important things to note:

### Mapping External Channels to Synnax Channels
- It is common to have a mapping of channels from the external system to Synnax channel
names/keys. 
- It is recommended to use the channel key in this mapping as channel names
do not have to be unique.

For complete information on how to handle channels, check out the [channels
guide](/reference/python-client/channels).


## Writing Data to Synnax

Writing data to Synnax is done the typical way using a
[writer](/reference/python-client/writers). 
A common workflow is:
1. Create a writer for the data channel.
2. Poll the external system for data.
3. Write the data to Synnax using the writer.
4. Repeat.

### Data Channel Conventions
- Data channels cannot store variable length values, such as strings or JSON objects.
- Every data channel must have an associated index channel that stores the timestamps of
  the data channel. 
- It's common to have multiple data channels that share the same index
  channel. 
- However, if you intend to have multiple data channels written to
  concurrently, you should create an index channel for each group of data channels on a
  per thread basis. E.g. if you have channels `data1` and `data2`, you should create
  - `index1` and `index2` if you intend to write to `data1` and `data2` using different
    writers on seperate threads.
  - only a single `index` if you intend to write to `data1` and `data2` using one writer
    on the one thread.




## Sending Commands from Synnax
A pair of channels is typically used to control a channel on the corresponding external
system: a command and a state channel. Command channels, typically suffixed with `_cmd`, are used to send commands to
the device. State channels, suffixed with `_state`, are used as acknowledgements from a
device driver that a command has been executed.

The folliowing setup faciliates a basic control flow:
- A synnax [streamer](/reference/python-client/streamers) is created in the driver to
  poll commands written to the command channel.
- A synnax [writer](/reference/python-client/writers) is created to write values to the
  state channel.
- Once a command is received, the appropriate call is made to take action on the external
  system.
- Once the command has been executed, the driver writes a value to the state channel to
  acknowledge the command.

Note this setup does not provide details on writing commands down the command channel. This
is typically done in a seperate set of code from the driver, such as a control sequence.
See the figure below for a visual representation of this setup:

<Image client:only="react" id="control/get-started/basic-control" themed={false} />

For complete information on how to handle commands, please read the sections on
[Controlling Hardware](/reference/control/get-started) .
