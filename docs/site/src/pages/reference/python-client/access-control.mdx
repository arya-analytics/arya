---
layout: "@/layouts/MainLayout.astro"
title: "Access Control"
description: "Learn how to use access control in the Python client."
---
import { Divider } from "@synnaxlabs/pluto"
import Code from "@/components/code/Code.astro";
import Note from "@/components/Note.astro";
export const components = { pre: Code };

Controlling access to writing and reading resources is crucial for mission-critical
systems. Synnax makes this process easy by implementing Role-Based Access Control (RBAC).
In essence, permissions to resources are governed by a set of policies dictating which
users can perform what actions on which resources.

<Divider.Divider direction="x" />

## Users

The root user (user created upon creating the cluster), by default, has every access
permission enabled, including the ability to create more users. To create a user, use
the `register()` function in the client library:

```
# log in to the root user
client = sy.Synnax()
# new_user is an object containing that user's UUID key and username
new_user = client.user.register(new_username, new_password)
```

After registration, the new user is able to log in via a client library or the console.
However, note that before the root user grants access to the new user, the latter cannot
interact with the cluster. The access is granted via the use of policies.

## Policies

A policy has three important fields: subjects, objects, and actions.
```python
class Policy(Payload):
    key: uuid.UUID | None = None
    subjects: list[OntologyID] = None
    objects: list[OntologyID] = None
    actions: list[str] = None
```
Like in an English sentence, a [subject] performs an [action] on [objects]. For example,
a policy where `subjects=[user1, user2]`, `objects=[channel1, schematic2]`, 
`actions=["read", "create"]` indicate that users `user1` and `user2` can read and write to
`channel1` and `schematic2`.

An `OntologyID` is an ID that uniquely identifies a resource: it comprises a type and
a key. If the key is empty, then the `OntologyID` applies to all resources of that type.
For example, `OntologyID(type="channel", key="65231")` uniquely identifies the channel,
and `OntologyID(type="schematic")` applies to every resource of the type `schematic`.

### Subjects

The `subjects` field is a list of `OntologyID`s that uniquely identify a user.
To get an `OntologyID` for a user, call the `ontology_id()` method from a
user object returned from `register`.

### Objects

The `objects` field is a list of `OntologyID`s representing resources granted to the
subjects in this policy. There are three types of `OntologyID`s to use for the `objects`
field:
- Ontology type ID, which grants a user ALL resources of a certain type. For example, if
an object of the policy is `channel_ontology_type`, then the policy applies to ALL
channels.
- Specific Ontology ID, which grants a user one resource of a certain type. For example,
if an object of the policy is an `OntologyID` of type "channel" and of key "65535", then
the policy only applies to the channel of key 65535.
- The `ALLOW_ALL` Ontology ID, which is a special `OntologyID` that allows ALL requests from
the subjects. This is a very dangerous privilege to give.

### Actions

The `actions` field is a list of strings representing the actions allowed by the policy
on the objects. All actions recognized by the API fall under one of four operations:
`"create"`, `"retrieve"`, `"update"`, and `"delete"`, so one of them should be set for
every policy.

<Note variant="info">
The privilege to access policies itself is a policy type. Only a user with a policy of
object type `policy` and defined actions is allowed to modify policies.
</Note>

## Example

```python
new_user = client.user.register(new_username, new_password)
client2 = sy.Synnax(
    host=host,
    port=port,
    username=new_username,
    password=new_password,
)

# Use the root user to give the new user permission to create channels.
client.access.create(
    subjects=[new_user.ontology_id()],
    objects=[channel_ontology_type],
    actions=["create", "retrieve", "delete"],
)

# Now, the user is allowed to create channels.
ch = client2.channels.create(
    sy.Channel(
        name="new_channel",
        data_type=sy.DataType.FLOAT32,
        rate=1 * sy.Rate.HZ,
    )
)

# Use the root user to give the new user permission to read, write, delete data from channels.
client.access.create(
    subjects=[new_user.ontology_id()],
    objects=[sy.ontology.OntologyID(key=ch.key, type="framer")],
    actions=["create"],
)

# It's also possible to retrieve policies by subject.
# Here, policies would have length 2 with the two policies created on it.
policies = client.access.retrieve(new_user.ontology_id())

# A user can delete a policy by its key, which can be found from the policies returned
# by a retrieve operation.
client.access.delete(policies[0].key)
```
