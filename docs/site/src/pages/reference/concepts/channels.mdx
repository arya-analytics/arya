---
layout: "@/layouts/MainLayout.astro"
title: "Channels"
description: "Learn how channels represent data in Synnax."
---
import {Image} from "astro:assets";
import { Divider, Text } from "@synnaxlabs/pluto"
import Diagram from "@/components/Diagram.astro"
import { Icon } from "@synnaxlabs/media";
import g9 from "@/pages/reference/concepts/Frame 8.svg"
import Note from "@/components/Note.astro"

This page walks you through what channels are, their important properties, and
how to use them when structuring your cluster.

If you’re looking for a practical guide on creating or retrieving channels,
visit the respective pages for the [Python](../python-client/channels) and
[TypeScript](../typescript-client/channels) clients.

<Divider.Divider direction="x" />

## Introduction

A channel is a logical collection of samples emitted by or representing the
values of a single source. This source is typically a sensor, although channels can 
also hold actuator commands, post-processed results, or any other time-ordered data. 

Channels are used for both **data storage** and **real-time communication**. A sensor 
recording samples 25 times per second (or 25Hz) would write data to a channel in order 
to store it permanently within Synnax, while at the same time streaming the data
for live consumption.

The following diagram shows a sensor writing samples to a channel, which are then
stored and forwarded to a visualization tool and analysis script.

<Diagram>
<Image src={g9} alt="Channel Diagram" />
</Diagram>

Channels are comparable to **tags** in a time-series database like [InfluxDB](https://www.influxdata.com/)
or SCADA system like [Ignition](https://inductiveautomation.com/). It's common for a single Synnax
database to have hundreds or thousands of channels, each of which represents a different
data source.

<Divider.Divider direction="x" />

## Channel Types

There are three different classifications of channel in Synnax: **index, indexed, and 
virtual channels.**

Synnax is a time-series database. Every respective channel must have a time
channel that it is indexed to. These index channels allow for data lookup at a
particular time. There are two main types of channels:

1. Indexed Channels - Stores data arriving at a variable rate. The samples in
   these channels are ‘indexed’ by a specified index channel.
2. Index Channels - Stores the timestamps for samples in one or more indexed
   channels. The samples in these channels must be time-ordered, nanosecond
   integers. Timestamps in index channels are used to look up the samples in the
   channels ‘indexed’ by them.

An index channel (or just “index”) is a special type of channel optimized for
fast lookups on timestamps. The values in an indexed channel must be
time-ordered, `int64` nanosecond UTC timestamps. Synnax provides utilities for
converting between timestamp formats and timezones.

Indexed channels are ‘indexed’ by the values in an index channel, which means
that each sample in the indexed channel has a correlated timestamp in its index.
Multiple indexed channels can have the same channel as their index. By
efficiently finding the location of the timestamp, Synnax can also quickly
retrieve the associated samples.

Index channels play a similar role to primary keys in relational databases. The
primary key (in Synnax’s case, a timestamp) can be used to fetch related values
in one or more columns quickly.

{/* Have Emiliano rewrite this above section.*/}

<Divider.Divider direction="x" />

## Channel Fields

### Key

A channel’s key is auto-assigned by the cluster and is guaranteed to be unique.

### Name

A human-readable name for the channel. Synnax does not prevent duplicate names,
but we highly recommend that you keep them unique.

{/* Is the above still true? */}

### Data Type

The data type of the samples stored in the channel. A channel’s data type must
have a fixed **density** i.e. the number of bytes per sample is constant. Synnax
has a number of built in data types:

| Data Type   | Description                   | Density |
| ----------- | ----------------------------- | ------- |
| `bool`      | Boolean value                 | 1 byte  |
| `int8`      | Signed 8-bit integer          | 1 byte  |
| `int16`     | Signed 16-bit integer         | 2 bytes |
| `int32`     | Signed 32-bit integer         | 4 bytes |
| `int64`     | Signed 64-bit integer         | 8 bytes |
| `uint8`     | Unsigned 8-bit integer        | 1 byte  |
| `uint16`    | Unsigned 16-bit integer       | 2 bytes |
| `uint32`    | Unsigned 32-bit integer       | 4 bytes |
| `uint64`    | Unsigned 64-bit integer       | 8 bytes |
| `timestamp` | 64-bit nanosecond UTC integer | 8 bytes |
| `float32`   | 32-bit floating point         | 4 bytes |
| `float64`   | 64-bit floating point         | 8 bytes |

We’re also planning on adding support for custom data types such as fixed-size
JSON objects and arrays. If this is something that interests you, let us know.

### Is Index

If this value is true, the channel is considered an index channel. Index
channels must have a data type of `timestamp`, meaning that they must contain
ordered `int64` nanosecond UTC timestamps.

### Index

If the channel is not an index channel, this should be set to the key of the
index channel. If this parameter is provided, the channel is considered an
indexed channel. This field will be ignored for index channels, as they cannot
be indexed.
