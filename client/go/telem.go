// Code generated by reexport-gen; DO NOT EDIT.

package synnax

import (
	original "github.com/synnaxlabs/x/telem"
	"github.com/synnaxlabs/x/types"
	"time"
)

const (
	// TimeStampMin represents the minimum value for a TimeStamp
	TimeStampMin = original.TimeStampMin
	// TimeStampMax represents the maximum value for a TimeStamp
	TimeStampMax = original.TimeStampMax
	// TimeSpanZero represents the zero value for a TimeSpan.
	TimeSpanZero = original.TimeSpanZero
	// TimeSpanMax represents the maximum possible TimeSpan.
	TimeSpanMax = original.TimeSpanMax
	Nanosecond = original.Nanosecond
	NanosecondTS = original.NanosecondTS
	Microsecond = original.Microsecond
	MicrosecondTS = original.MicrosecondTS
	Millisecond = original.Millisecond
	MillisecondTS = original.MillisecondTS
	Second = original.Second
	SecondTS = original.SecondTS
	Minute = original.Minute
	MinuteTS = original.MinuteTS
	Hour = original.Hour
	HourTS = original.HourTS
	Day = original.Day
	DayTS = original.DayTS
	ByteSize = original.ByteSize
	Kilobyte = original.Kilobyte
	Megabyte = original.Megabyte
	Gigabyte = original.Gigabyte
	// Hz represents a data rate of 1 Hz.
	Hz = original.Hz
	KHz = original.KHz
	MHz = original.MHz
	DensityUnknown = original.DensityUnknown
	Bit128 = original.Bit128
	Bit64 = original.Bit64
	Bit32 = original.Bit32
	Bit16 = original.Bit16
	Bit8 = original.Bit8
	TimeStampDensity = original.TimeStampDensity
	TimeSpanDensity = original.TimeSpanDensity
	// ZeroLeadingAlignment represents the start of a region reserved for written data that
	// has not yet been persisted. This is useful for correctly ordering new data while
	// ensuring that it is significantly after any persisted data.
	ZeroLeadingAlignment = original.ZeroLeadingAlignment
)

var (
	UnknownT = original.UnknownT
	TimeStampT = original.TimeStampT
	UUIDT = original.UUIDT
	Float64T = original.Float64T
	Float32T = original.Float32T
	Int64T = original.Int64T
	Int32T = original.Int32T
	Int16T = original.Int16T
	Int8T = original.Int8T
	Uint64T = original.Uint64T
	Uint32T = original.Uint32T
	Uint16T = original.Uint16T
	Uint8T = original.Uint8T
	BytesT = original.BytesT
	StringT = original.StringT
	JSONT = original.JSONT
	ByteOrder = original.ByteOrder
	// TimeRangeMax represents the maximum possible value for a TimeRange.
	TimeRangeMax = original.TimeRangeMax
	// TimeRangeMin represents the minimum possible value for a TimeRange.
	TimeRangeMin = original.TimeRangeMin
	// TimeRangeZero represents the zero value for a TimeRange.
	TimeRangeZero = original.TimeRangeZero
)

// DataType is a string that represents a data type.
type DataType = original.DataType

type Series = original.Series

type Value = original.Value

// TimeStamp stores an epoch time in nanoseconds.
type TimeStamp = original.TimeStamp

// TimeRange represents a range of time between two TimeStamp. It's important
// to note that the start of the range is inclusive, while the end of the range is
// exclusive.
type TimeRange = original.TimeRange

// TimeSpan represents a duration of time in nanoseconds.
type TimeSpan = original.TimeSpan

// Size represents the size of an element in bytes.
type Size = original.Size

type Offset = original.Offset

// Rate represents a rate in Hz.
type Rate = original.Rate

// Density represents a density in bytes per value.
type Density = original.Density

// AlignmentPair is essentially two array index values that can be used to represent
// the location of a sample within a group of arrays. For example, if you have two arrays
// that have 50 elements each, and you want the 15th element of the second array, you would
// use NewAlignmentPair(1, 15). The first index is called the 'domain index' and the second
// index is called the 'sample index'. The domain index is the index of the array, and the
// sample index is the index of the sample within that array.
//
// You may think a better design is to just use a single number that overflows the arrays
// before it i.e. the value of our previous example would be 50 + 14 = 64. However, this
// requires us to know the size of all arrays, which is not always possible.
//
// While not as meaningful as a single number, AlignmentPair is a uint64 that guarantees
// that a larger value is, in fact, 'positionally' after a smaller value. This is useful
// for ordering samples correctly.
type AlignmentPair = original.AlignmentPair

type PBTimeRange = original.PBTimeRange

type PBSeries = original.PBSeries

func NewDataType[T any](v T) DataType {
	return original.NewDataType[T](v)
}

func TranslateTimeRangeForward(tr TimeRange) *PBTimeRange {
	return original.TranslateTimeRangeForward(tr)
}

func TranslateTimeRangeBackward(tr *PBTimeRange) (otr TimeRange) {
	return original.TranslateTimeRangeBackward(tr)
}

func TranslateSeriesForward(s Series) *PBSeries {
	return original.TranslateSeriesForward(s)
}

func TranslateManySeriesForward(s []Series) []*PBSeries {
	return original.TranslateManySeriesForward(s)
}

func TranslateSeriesBackward(s *PBSeries) Series {
	return original.TranslateSeriesBackward(s)
}

func TranslateManySeriesBackward(s []*PBSeries) []Series {
	return original.TranslateManySeriesBackward(s)
}

// ValueAt returns the value at the given index in the series.
func ValueAt[T types.Numeric](s Series, i int64) T {
	return original.ValueAt[T](s, i)
}

func NewSeries[T Value](data []T) (series Series) {
	return original.NewSeries[T](data)
}

func NewSeriesV[T Value](data ...T) (series Series) {
	return original.NewSeriesV[T](data...)
}

func NewSecondsTSV(data ...TimeStamp) (series Series) {
	return original.NewSecondsTSV(data...)
}

func NewStrings(data []string) (series Series) {
	return original.NewStrings(data)
}

func NewStringsV(data ...string) (series Series) {
	return original.NewStringsV(data...)
}

func MarshalStrings(data []string, dt DataType) []byte {
	return original.MarshalStrings(data, dt)
}

func UnmarshalStrings(b []byte) (data []string) {
	return original.UnmarshalStrings(b)
}

func MarshalSlice[T Value](data []T, dt DataType) []byte {
	return original.MarshalSlice[T](data, dt)
}

func UnmarshalSlice[T Value](b []byte, dt DataType) (data []T) {
	return original.UnmarshalSlice[T](b, dt)
}

func Unmarshal[T Value](series Series) []T {
	return original.Unmarshal[T](series)
}

// Now returns the current time as a TimeStamp.
func Now() TimeStamp {
	return original.Now()
}

// NewTimeStamp creates a new TimeStamp from a time.Time.
func NewTimeStamp(t time.Time) TimeStamp {
	return original.NewTimeStamp(t)
}

// NewAlignmentPair takes the given array index and sample index within that array and
// returns a new AlignmentPair (see AlignmentPair for more information).
func NewAlignmentPair(domainIdx uint32, sampleIdx uint32) AlignmentPair {
	return original.NewAlignmentPair(domainIdx, sampleIdx)
}

// LeadingAlignment returns an AlignmentPair whose array index is the maximum possible value
// and whose sample index is the provided value.
func LeadingAlignment(domainIdx uint32, sampleIdx uint32) AlignmentPair {
	return original.LeadingAlignment(domainIdx, sampleIdx)
}
